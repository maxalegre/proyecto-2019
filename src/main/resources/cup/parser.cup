package uy.edu.ucu.jsonql2019.parser;

import uy.edu.ucu.jsonql2019.ast.*;
import java.io.*;
import java.util.*;
import java_cup.runtime.Symbol;

parser code {:
	public void syntax_error(Symbol currentToken) {
		report_error("Syntax error at [" + (currentToken.left+1) +"," + (currentToken.right+1) +"]", null);
	}

	public static Symbol parse(Reader input) throws Exception {
		return (new JSONQLParser(new JSONQLLexer(input))).parse();
	}

	public static void main(String[] args) throws Exception {
		if (args.length < 1) {
			System.out.println(parse(new InputStreamReader(System.in, "UTF8")).value);
		} else for (int i = 0; i < args.length; ++i) {
			System.out.println(parse(new InputStreamReader(new FileInputStream(args[i]), "UTF8")).value);
		}
	}
:}

terminal ROOT, MULT, DIV,LPARENT, RPARENT, EQUAL, NOT_EQUAL, LESS, GREATER, LESS_EQUAL, GREATER_EQUAL, NOT, AND, OR, PLUS, MINUS, LBRACE,RBRACE,LBRACK,RBRACK, COLON, COMMA, NULL;
terminal Double NUMBER;
terminal String	STRING;
terminal Boolean BOOL;

non terminal JSONQLExpression S;
non terminal JSONQLExpression EXP;
non terminal JSONQLObjectExpression OBJECT; 
non terminal JSONQLArrayExpression ARRAY;       
non terminal List<JSONQLMemberExpression> VALUES;
non terminal Map<String,Object> PAIRS;  

precedence left PLUS, MINUS;   
precedence left MULT, DIV;   
precedence left AND, EQUAL, OR, NOT_EQUAL, GREATER, LESS, GREATER_EQUAL, LESS_EQUAL;

start with S;

S ::= EXP:op {: RESULT=op; :};  

EXP ::= ROOT {: RESULT = JSONQLRoot.ROOT; :} |
		BOOL:b {:RESULT = new JSONQLLiteral(b);:}
		NUMBER:n {:RESULT = new JSONQLLiteral(n);:} |
		STRING:s {:RESULT = new JSONQLLiteral(s);:} |
	  	NULL {:RESULT = new JSONQLLiteral(null);:} |
       	OBJECT:o {:RESULT = o;:} |  
       	ARRAY:a  {:RESULT = a;:} |
       	LPARENT EXP:r RPARENT {: RESULT = r;:} |
       	EXP:l MULT EXP:r {: RESULT = new JSONQLBinaryExpression("*",l,r); :} |
		EXP:l DIV EXP:r {: RESULT = new JSONQLBinaryExpression("/",l,r); :} |
		EXP:l PLUS EXP:r {: RESULT = new JSONQLBinaryExpression("+",l,r); :} |
		EXP:l MINUS EXP:r {: RESULT = new JSONQLBinaryExpression("-",l,r); :} |
       	EXP:n1 EQUAL EXP:n2 {:RESULT= new JSONQLBinaryExpression("==",n1,n2);:} |
		EXP:n1 NOT_EQUAL EXP:n2 {:RESULT= new JSONQLBinaryExpression("!=",n1,n2);:} |
		EXP:n1 LESS EXP:n2 {:RESULT= new JSONQLBinaryExpression("<",n1,n2);:} |
		EXP:n1 GREATER EXP:n2 {:RESULT= new JSONQLBinaryExpression(">",n1,n2);:} |
		EXP:n1 LESS_EQUAL EXP:n2 {:RESULT= new JSONQLBinaryExpression("<=",n1,n2);:} |
		EXP:n1 GREATER_EQUAL EXP:n2 {:RESULT= new JSONQLBinaryExpression(">=",n1,n2);:} |
		NOT EXP:b  {:RESULT=new JSONQLUnaryExpression("!",b);:} |
		EXP:n1 AND EXP:n2 {:RESULT= new JSONQLBinaryExpression("&&",n1,n2);:} |
		EXP:n1 OR EXP:n2 {:RESULT= new JSONQLBinaryExpression("||",n1,n2);:};   
           	
OBJECT ::= LBRACE RBRACE {:RESULT= new HashMap<String,Object>();:} | 
	       LBRACE PAIRS:p RBRACE {: RESULT=p; :}; 	
			
PAIRS  ::= STRING:k COLON EXP:v {:RESULT=new HashMap<String,Object>(); RESULT.put(k,v);:} | 
	       PAIRS:p COMMA STRING:k COLON EXP:v {:p.put(k,v); System.out.println("p: "+p); RESULT=p;:}; 
	   
ARRAY  ::= LBRACK RBRACK  {:JSONSQLArrayExpression[] a = new JSONSQLArrayExpression()[];RESULT= new JSONSQLArrayExpression(a);:} |
		   LBRACK VALUES:v RBRACK {:System.out.println("array: " + v); RESULT=v;:} ;
 
VALUES ::= EXP:v {:RESULT= new JSONSQLArrayExpression(v);:} |
           VALUES:a COMMA EXP:v {:a.elements.add(v); RESULT=a;:} ;

